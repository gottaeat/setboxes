# - - mss-otg begin - - #
# this is a dependency for some of the services as it provides the handler
# hooks
- name: install mss-otg utils + landfill
  hosts: crib
  become: yes
  tasks:
    # 1. check if we're on baremetal
    - name: check if mss_otg_path exists
      stat:
        path: "{{ mss_otg_path }}"
      register: otg_on_baremetal

    # 2. check if vm init was done
    - name: check if vm init was done
      stat:
        path: /var/lib/mss_ansible/otg_vm_init_done
      register: otg_vm_init

    # 3. we are in the vm, clone the repo
    - name: vm pre-install
      block:
        - name: set otg-path
          set_fact:
            otg_path: "/tmp/mss-otg"

        - name: clone mss-otg
          git:
            repo: "https://github.com/gottaeat/mss-otg"
            dest: "{{ otg_path }}"
            depth: 1
            recursive: yes
      when: not otg_on_baremetal.stat.exists and not otg_vm_init.stat.exists

    # 4. we are on baremetal
    - name: baremetal pre-install
      block:
        - name: set otg-path
          set_fact:
            otg_path: "{{ mss_otg_path }}"

        - name: read the hash of the installed otg
          block:
            - name: slurp the otg commit file
              slurp:
                src: /var/lib/mss_ansible/otg_commit
              register: otg_commit_hash_b64

            - name: decode the hash
              set_fact:
                installed_otg_hash: "{{ otg_commit_hash_b64['content'] | b64decode }}"
      when: otg_on_baremetal.stat.exists

    # 5. read the HEAD commit hash
    - name: read the hash of the head
      shell:
        chdir: "{{ otg_path }}"
        cmd: |
           git rev-parse --short HEAD
      register: head_otg_hash
      changed_when: false
      when: otg_on_baremetal.stat.exists or not otg_vm_init.stat.exists

    # 6. install when:
    #  a. we are in the vm and we never installed mss-otg
    #  b. we are on baremetal and the installed hash does not match the HEAD
    - name: build otg
      block:
        - name: create build directory
          file:
            path: "{{ otg_path }}/{{ item }}/build"
            state: directory
          with_items:
            - utils
            - landfill

        - name: build and install otg
          shell:
            chdir: "{{ otg_path }}/{{ item }}/build"
            cmd: |
              meson setup ../ && ninja && ninja install
          with_items:
            - utils
            - landfill

        - name: remove build artifacts
          file:
            path: "{{ otg_path }}/{{ item }}/build"
            state: absent
          with_items:
            - utils
            - landfill

        - name: update the hash
          copy:
            content: "{{ head_otg_hash }}"
            dest: /var/lib/mss_ansible/otg_commit

        - name: set otg_vm_init
          file:
            path: /var/lib/mss_ansible/otg_vm_init_done
            state: touch
            modification_time: preserve
            access_time: preserve
          when: not otg_vm_init.stat.exists
      when: (not otg_on_baremetal.stat.exists and not otg_vm_init.stat.exists ) or ( otg_on_baremetal.stat.exists and installed_otg_hash != head_otg_hash )

    # 7. post-install
    - name: set otg ownership
      file:
        path: "/mss/{{ item }}"
        owner: root
        group: root
        recurse: yes
      with_items:
        - "bin"
        - "etc"
        - "share"

    - name: install symlinks for the bash-handler
      file:
        src: "/mss/share/bash-handler"
        dest: "{{ item }}"
        state: link
        force: yes
      with_items:
        - "/etc/profile"
        - "/etc/bash.bashrc"

# - - mss-otg end - - #

# - - mss-nfqws begin - - #
- name: install mss-nfqws
  hosts: crib
  become: yes
  tasks:
    # 1. check if we're on baremetal
    - name: check if mss_nfqws_path exists
      stat:
        path: "{{ mss_nfqws_path }}"
      register: nfqws_on_baremetal

    # 2. check if vm init was done
    - name: check if vm init was done
      stat:
        path: /var/lib/mss_ansible/nfqws_vm_init_done
      register: nfqws_vm_init

    # 3. we are in the vm, clone the repo
    - name: vm pre-install
      block:
        - name: set nfqws-path
          set_fact:
            nfqws_path: "/tmp/mss-nfqws"

        - name: clone mss-nfqws
          git:
            repo: "https://github.com/gottaeat/mss-nfqws"
            dest: "{{ nfqws_path }}"
            depth: 1
            recursive: yes
      when: not nfqws_on_baremetal.stat.exists and not nfqws_vm_init.stat.exists

    # 4. we are on baremetal
    - name: baremetal pre-install
      block:
        - name: set nfqws-path
          set_fact:
            nfqws_path: "{{ mss_nfqws_path }}"

        - name: read the hash of the installed nfqws
          block:
            - name: slurp the nfqws commit file
              slurp:
                src: /var/lib/mss_ansible/nfqws_commit
              register: nfqws_commit_hash_b64

            - name: decode the hash
              set_fact:
                installed_nfqws_hash: "{{ nfqws_commit_hash_b64['content'] | b64decode }}"
      when: nfqws_on_baremetal.stat.exists

    # 5. read the HEAD commit hash
    - name: read the hash of the head
      shell:
        chdir: "{{ nfqws_path }}"
        cmd: |
           git rev-parse --short HEAD
      register: head_nfqws_hash
      changed_when: false
      when: nfqws_on_baremetal.stat.exists or not nfqws_vm_init.stat.exists

    # 6. install when:
    #  a. we are in the vm and we never installed mss-nfqws
    #  b. we are on baremetal and the installed hash does not match the HEAD
    - name: build nfqws
      block:
        - name: create build directory
          file:
            path: "{{ nfqws_path }}/build"
            state: directory

        - name: build and install nfqws
          shell:
            chdir: "{{ nfqws_path }}/build"
            cmd: |
              meson setup ../ && ninja && ninja install

        - name: remove build artifacts
          file:
            path: "{{ nfqws_path }}/build"
            state: absent

        - name: update the hash
          copy:
            content: "{{ head_nfqws_hash }}"
            dest: /var/lib/mss_ansible/nfqws_commit

        - name: set nfqws_vm_init
          file:
            path: /var/lib/mss_ansible/nfqws_vm_init_done
            state: touch
            modification_time: preserve
            access_time: preserve
          when: not nfqws_vm_init.stat.exists
      when: (not nfqws_on_baremetal.stat.exists and not nfqws_vm_init.stat.exists ) or ( nfqws_on_baremetal.stat.exists and installed_nfqws_hash != head_nfqws_hash )

# - - services begin - - #
- name: configure nftables
  hosts: crib
  become: yes
  tasks:
    - name: copy nftables.conf to /etc
      copy:
        src: "./files/nftables/{{ mss_hostname }}.nft"
        dest: /etc/nftables.conf
        owner: root
        group: root
        mode: '0700'
      notify: restart nftables

    - name: mask iptables
      systemd_service:
        name: iptables
        masked: true

  handlers:
    - name: restart nftables
      systemd_service:
        name: nftables
        state: restarted
        enabled: true

- name: configure wireguard
  hosts: crib
  become: yes
  tasks:
    - name: create client symlinks for {{ mss_hostname }}
      file:
        src: "/mnt/mss/stuff/techy-bits/vpn/lichen/client/{{ mss_hostname }}-{{ item }}.conf"
        dest: "/etc/wireguard/{{ item }}.conf"
        state: link
        force: true
        follow: false
      with_items: "{{ mss_wireguard_ifaces }}"

- name: configure bind
  hosts: crib
  become: yes
  roles:
    - role: ansible-resolv
      vars:
        resolv_nameservers:
          - "10.0.99.0"
        resolv_search:
          - "crib"
          - "lichen"
          - "lichenraw"
  pre_tasks:
    - name: copy over systemd overrides
      copy:
        src: ./dir/etc/systemd/system/named.service.d
        dest: /etc/systemd/system
        owner: root
        group: root
        mode: '0640'
      register: named_systemd_override

    - name: daemon reload
      systemd_service:
        daemon_reload: true
      when: named_systemd_override.changed

    - name: base named configuration
      ansible.posix.synchronize:
        src: "./dir/etc/{{ item }}"
        dest: /etc
        archive: yes
        delete: false
        owner: false
        group: false
        times: false
        checksum: true
        rsync_opts:
            - "--chown=named:named"
            - "--chmod=F640"
      with_items:
        - named.conf
        - rndc.conf
      register: base_named_copy

    - name: zonefiles
      ansible.posix.synchronize:
        src: ./dir/var/named
        dest: /var
        archive: yes
        delete: true
        owner: false
        group: false
        times: false
        checksum: true
        rsync_opts:
            - "--chown=named:named"
            - "--chmod=D750,F640"
      register: zone_named_copy

    - name: generate /etc/rndc.key
      command:
        cmd: rndc-confgen -a -c /etc/rndc.key
        creates: /etc/rndc.key

    - name: set perms for rndc.key
      file:
        path: /etc/rndc.key
        owner: root
        group: named
        mode: '0640'

    - name: set named state
      systemd_service:
        name: named
        state: "{{ 'restarted' if named_systemd_override.changed or base_named_copy.changed or zone_named_copy.changed else 'started' }}"
        enabled: true

- name: configure docker
  hosts: crib
  become: yes
  tasks:
    - name: copy over dockerns service
      copy:
        src: ./dir/etc/systemd/system/dockerns.service
        dest: /etc/systemd/system
        owner: root
        group: root
        mode: '0644'
      register: dockerns_copy

    - name: copy over docker overrides
      copy:
        src: ./dir/etc/systemd/system/docker.service.d
        dest: /etc/systemd/system
        owner: root
        group: root
        mode: '0644'
      register: docker_systemd_override

    - name: modify docker and containerd LimitNOFILE
      replace:
        path: "/usr/lib/systemd/system/{{ item }}.service"
        regexp: 'LimitNOFILE=infinity'
        replace: 'LimitNOFILE=1024:524288'
      with_items:
        - containerd
        - docker
      register: docker_systemd_file_replace

    - name: daemon reload
      systemd_service:
        daemon_reload: true
      when: ( dockerns_copy.changed or docker_systemd_override.changed or docker_systemd_file_replace.changed )

    - name: set dockerns state
      systemd_service:
        name: dockerns
        state: "{{ 'restarted' if dockerns_copy.changed else 'started' }}"
        enabled: true
      register: dockerns_service_state
      when: dockerns_copy.changed

    - name: set docker state
      systemd_service:
        name: "{{ item }}"
        state: "{{ 'restarted' if docker_systemd_override.changed or docker_systemd_file_replace.changed else 'started' }}"
        enabled: true
      with_items:
        - docker
        - containerd

- name: configure libvirt
  hosts: crib
  become: yes
  tasks:
    - name: set up libvirt service
      block:
        - name: copy over libvirtdns service
          copy:
            src: ./dir/etc/systemd/system/libvirtdns.service
            dest: /etc/systemd/system
            owner: root
            group: root
            mode: '0644'
          register: libvirtdns_copy

        - name: copy over libvirtd overrides
          copy:
            src: ./dir/etc/systemd/system/libvirtd.service.d
            dest: /etc/systemd/system
            owner: root
            group: root
            mode: '0644'
          register: libvirtd_systemd_override

        - name: daemon reload
          systemd_service:
            daemon_reload: true
          when: ( libvirtdns_copy.changed or libvirtd_systemd_override.changed )

        - name: set libvirtdns state
          systemd_service:
            name: libvirtdns
            state: "{{ 'restarted' if libvirtdns_copy.changed else 'started' }}"
            enabled: true

        - name: set libvirt state
          systemd_service:
            name: "{{ item }}"
            state: "{{ 'restarted' if libvirtd_systemd_override.changed else 'started' }}"
            enabled: true
          with_items:
            - libvirtd
            - virtlogd

    - name: baremetal check
      stat:
        path: /mnt/mss/stuff/techy-bits/pools
      register: on_baremetal

    - name: set up boxes
      block:
        - name: define networks
          community.libvirt.virt_net:
            command: define
            name: "{{ item.name }}"
            xml: '{{ lookup("file", item.xml) }}'
          with_items:
            - { name: "gat", xml: "./virtxml/net_gat.xml" }
            - { name: "cumvirt", xml: "./virtxml/net_cumvirt.xml" }

        - name: define pools
          community.libvirt.virt_pool:
            command: define
            name: "{{ item.name }}"
            xml: '{{ lookup("file", item.xml) }}'
          with_items:
            - { name: "cumvirt", xml: "./virtxml/pool_cumvirt.xml" }
            - { name: "gat", xml: "./virtxml/pool_gat.xml" }
            - { name: "iso", xml: "./virtxml/pool_iso.xml" }

        - name: set network status
          community.libvirt.virt_net:
            autostart: true
            state: active
            name: "{{ item }}"
          with_items:
            - cumvirt
            - gat
          when: on_baremetal.stat.exists

        - name: set pool status
          community.libvirt.virt_pool:
            autostart: true
            state: active
            name: "{{ item }}"
          with_items:
            - cumvirt
            - gat
            - iso
          when: on_baremetal.stat.exists

        - name: define domains
          community.libvirt.virt:
            command: define
            autostart: false
            xml: '{{ lookup("file", item) }}'
          with_items:
            - virtxml/dom_win10-ltsc-21h2.xml
          when: on_baremetal.stat.exists

- name: configure pulseaudio
  hosts: crib
  become: yes
  tasks:
    # need to take a reboot for this normally, but this file never changes and
    # it gets copied over when we're setting up in the vm, should not fuck
    # anything up
    - name: copy over dbus policy overrides
      copy:
        src: ./dir/usr/share/dbus-1/system.d/pulseaudio.conf
        dest: /usr/share/dbus-1/system.d/
        owner: root
        group: root
        mode: '0644'

    - name: configure user pulse
      block:
        - name: add pulseaudio groups
          ansible.builtin.group:
            name: "{{ item }}"
            state: present
          with_items:
            - pulse
            - pulse-access

        - name: add pulse user
          ansible.builtin.user:
            name: pulse
            group: pulse
            groups: audio
            append: false
            system: true
            create_home: true
            home: /var/run/pulse
            skeleton: /dev/null
            expires: -1
            state: present

    - name: copy over pulseaudio configuration
      copy:
        src: "./dir/etc/pulse/{{ item }}.conf"
        dest: /etc/pulse/
        owner: root
        group: root
        mode: '0644'
      with_items:
        - client
        - daemon
      notify: restart pulseaudio

    - name: set pulseaudio to use the socket
      replace:
        path: "/etc/pulse/{{ item }}.pa"
        regexp: "^load-module module-native-protocol-unix$"
        replace: "load-module module-native-protocol-unix auth-anonymous=1 socket=/var/run/pulse/native"
      notify: restart pulseaudio
      with_items:
        - default
        - system

    - name: copy over pulseaudio systemd service
      copy:
        src: "./dir/etc/systemd/system/pulseaudio.service"
        dest: /etc/systemd/system
        owner: root
        group: root
        mode: '0644'
      notify: restart pulseaudio

  handlers:
    - name: restart pulseaudio
      systemd_service:
        name: pulseaudio
        state: restarted
        enabled: true

- name: configure mpd
  hosts: crib
  become: yes
  tasks:
    - name: copy over mpd config
      copy:
        src: ./dir/etc/mpd.conf
        dest: /etc
        owner: root
        group: root
        mode: '0644'
      register: mpd_copy

    - name: mask mpd.socket
      systemd_service:
        name: mpd.socket
        enabled: false
        masked: true

    - name: set mpd state
      systemd_service:
        name: mpd
        state: "{{ 'restarted' if mpd_copy.changed else 'started' }}"
        enabled: true

- name: configure ntpd
  hosts: crib
  become: yes
  tasks:
    - name: copy over ntpd config
      copy:
        src: ./dir/etc/ntp.conf
        dest: /etc
        owner: root
        group: root
        mode: '0644'
      register: ntpd_copy

    - name: set ntpd state
      systemd_service:
        name: ntpd
        state: "{{ 'restarted' if ntpd_copy.changed else 'started' }}"
        enabled: true

- name: configure tor
  hosts: crib
  become: yes
  tasks:
    - name: copy over proxychains config
      copy:
        src: ./dir/etc/proxychains.conf
        dest: /etc
        owner: root
        group: root
        mode: '0644'

    - name: set tor state
      systemd_service:
        name: tor
        state: started
        enabled: true

- name: bulk enable extra services
  hosts: crib
  become: yes
  tasks:
    - name: bulk enable extra services
      systemd_service:
        name: "{{ item }}"
        state: started
        enabled: true
      with_items:
        - gpm
        - qbittorrent-nox@mss.service
        - vnstat

    - name: enable but do not start module cleanup
      systemd_services:
        name: linux-modules-cleanup
        enabled: true

# - - services end - - #

# - - misc begin - - #
- name: configure vim
  hosts: crib
  become: yes
  vars:
    dir: [ ['/root', 'root'], ['/home/mss', 'mss'] ]
    subdir: [ 'backups', 'swaps' ]
  tasks:
    - name: copy over vim configuration
      copy:
        src: ./dir/etc/vimrc
        dest: /etc
        owner: root
        group: root
        mode: '0644'

    - name: create directories
      file:
        path: "{{ item.0.0 }}/.config/vim/{{ item.1 }}"
        owner: "{{ item.0.1 }}"
        group: "{{ item.0.1 }}"
        state: directory
      loop: "{{ dir | product(subdir) | list }}"

- name: configure x11
  hosts: crib
  become: yes
  tasks:
    - name: allow x11 to run as root
      copy:
        src: ./dir/etc/X11/Xwrapper.config
        dest: /etc/X11
        owner: root
        group: root
        mode: '0644'

    - name: copy xorg-server config for host
      copy:
        src: "./dir/etc/X11/xorg.conf.d/01-{{ mss_hostname }}.conf"
        dest: /etc/X11/xorg.conf.d
        owner: root
        group: root
        mode: '0644'

# - - misc end - - #

# - - aur begin - - #
- name: handle aur
  hosts: crib
  become: yes
  vars_files:
    - files/pkglist/user.yml
  tasks:
    - name: create aur user
      user:
        name: aur
        group: wheel
        append: false
        create_home: true
        skeleton: /dev/null
        expires: -1
        state: present

    - name: allow aur to run pacman as root w/o a password
      copy:
        content: |
          aur ALL=(ALL) NOPASSWD: /usr/bin/pacman
        dest: /etc/sudoers.d/aur
        owner: root
        group: root
        mode: '0400'

    - name: check if yay is installed
      stat:
        path: /usr/bin/yay
      register: yay_installed

    - name: build yay
      become_user: aur
      block:
        - name: clone repo
          git:
            repo: "https://aur.archlinux.org/yay.git"
            dest: /tmp/yay
            depth: 1
            recursive: yes

        - name: build and install yay
          shell:
            chdir: /tmp/yay
            cmd: |
                makepkg -sri --noconfirm
      when: not yay_installed.stat.exists

    - name: install aur packages
      become_user: aur
      block:
        - name: update and upgrade
          kewlfft.aur.aur:
            update_cache: yes
            upgrade: yes
            use: yay

        - name: install the packages
          kewlfft.aur.aur:
            name: "{{ (mss_user_pkgs_base + mss_user_pkgs_extra) }}"
            use: yay

# - - aur end - - #
